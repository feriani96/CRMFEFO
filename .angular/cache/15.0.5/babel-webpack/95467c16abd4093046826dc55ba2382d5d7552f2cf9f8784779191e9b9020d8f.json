{"ast":null,"code":"import { Observable } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n/**\r\n * An utility service for data.\r\n */\nexport class DataUtils {\n  /**\r\n   * Method to find the byte size of the string provides\r\n   */\n  byteSize(base64String) {\n    return this.formatAsBytes(this.size(base64String));\n  }\n  /**\r\n   * Method to open file\r\n   */\n  openFile(data, contentType) {\n    contentType = contentType ?? '';\n    const byteCharacters = atob(data);\n    const byteNumbers = new Array(byteCharacters.length);\n    for (let i = 0; i < byteCharacters.length; i++) {\n      byteNumbers[i] = byteCharacters.charCodeAt(i);\n    }\n    const byteArray = new Uint8Array(byteNumbers);\n    const blob = new Blob([byteArray], {\n      type: contentType\n    });\n    const fileURL = window.URL.createObjectURL(blob);\n    const win = window.open(fileURL);\n    win.onload = function () {\n      URL.revokeObjectURL(fileURL);\n    };\n  }\n  /**\r\n   * Sets the base 64 data & file type of the 1st file on the event (event.target.files[0]) in the passed entity object\r\n   * and returns an observable.\r\n   *\r\n   * @param event the object containing the file (at event.target.files[0])\r\n   * @param editForm the form group where the input field is located\r\n   * @param field the field name to set the file's 'base 64 data' on\r\n   * @param isImage boolean representing if the file represented by the event is an image\r\n   * @returns an observable that loads file to form field and completes if sussessful\r\n   *      or returns error as FileLoadError on failure\r\n   */\n  loadFileToForm(event, editForm, field, isImage) {\n    return new Observable(observer => {\n      const eventTarget = event.target;\n      if (eventTarget?.files?.[0]) {\n        const file = eventTarget.files[0];\n        if (isImage && !file.type.startsWith('image/')) {\n          const error = {\n            message: `File was expected to be an image but was found to be '${file.type}'`,\n            key: 'not.image',\n            params: {\n              fileType: file.type\n            }\n          };\n          observer.error(error);\n        } else {\n          const fieldContentType = field + 'ContentType';\n          this.toBase64(file, base64Data => {\n            editForm.patchValue({\n              [field]: base64Data,\n              [fieldContentType]: file.type\n            });\n            observer.next();\n            observer.complete();\n          });\n        }\n      } else {\n        const error = {\n          message: 'Could not extract file',\n          key: 'could.not.extract',\n          params: {\n            event\n          }\n        };\n        observer.error(error);\n      }\n    });\n  }\n  /**\r\n   * Method to convert the file to base64\r\n   */\n  toBase64(file, callback) {\n    const fileReader = new FileReader();\n    fileReader.onload = e => {\n      if (typeof e.target?.result === 'string') {\n        const base64Data = e.target.result.substring(e.target.result.indexOf('base64,') + 'base64,'.length);\n        callback(base64Data);\n      }\n    };\n    fileReader.readAsDataURL(file);\n  }\n  endsWith(suffix, str) {\n    return str.includes(suffix, str.length - suffix.length);\n  }\n  paddingSize(value) {\n    if (this.endsWith('==', value)) {\n      return 2;\n    }\n    if (this.endsWith('=', value)) {\n      return 1;\n    }\n    return 0;\n  }\n  size(value) {\n    return value.length / 4 * 3 - this.paddingSize(value);\n  }\n  formatAsBytes(size) {\n    return size.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ' ') + ' bytes'; // NOSONAR\n  }\n}\n\nDataUtils.ɵfac = function DataUtils_Factory(t) {\n  return new (t || DataUtils)();\n};\nDataUtils.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: DataUtils,\n  factory: DataUtils.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["Observable","DataUtils","byteSize","base64String","formatAsBytes","size","openFile","data","contentType","byteCharacters","atob","byteNumbers","Array","length","i","charCodeAt","byteArray","Uint8Array","blob","Blob","type","fileURL","window","URL","createObjectURL","win","open","onload","revokeObjectURL","loadFileToForm","event","editForm","field","isImage","observer","eventTarget","target","files","file","startsWith","error","message","key","params","fileType","fieldContentType","toBase64","base64Data","patchValue","next","complete","callback","fileReader","FileReader","e","result","substring","indexOf","readAsDataURL","endsWith","suffix","str","includes","paddingSize","value","toString","replace","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\hp\\techWebAvancee\\CRM PROJECT\\CRMFEFO\\src\\app\\service\\data-util.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { FormGroup } from '@angular/forms';\r\nimport { Observable, Observer } from 'rxjs';\r\n\r\nexport type FileLoadErrorType = 'not.image' | 'could.not.extract';\r\n\r\nexport interface FileLoadError {\r\n  message: string;\r\n  key: FileLoadErrorType;\r\n  params?: any;\r\n}\r\n\r\n/**\r\n * An utility service for data.\r\n */\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\n\r\n\r\nexport class DataUtils {\r\n  /**\r\n   * Method to find the byte size of the string provides\r\n   */\r\n  byteSize(base64String: string): string {\r\n    return this.formatAsBytes(this.size(base64String));\r\n  }\r\n\r\n  /**\r\n   * Method to open file\r\n   */\r\n  openFile(data: string, contentType: string | null | undefined): void {\r\n    contentType = contentType ?? '';\r\n\r\n    const byteCharacters = atob(data);\r\n    const byteNumbers = new Array(byteCharacters.length);\r\n    for (let i = 0; i < byteCharacters.length; i++) {\r\n      byteNumbers[i] = byteCharacters.charCodeAt(i);\r\n    }\r\n    const byteArray = new Uint8Array(byteNumbers);\r\n    const blob = new Blob([byteArray], {\r\n      type: contentType,\r\n    });\r\n    const fileURL = window.URL.createObjectURL(blob);\r\n    const win = window.open(fileURL);\r\n    win!.onload = function () {\r\n      URL.revokeObjectURL(fileURL);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Sets the base 64 data & file type of the 1st file on the event (event.target.files[0]) in the passed entity object\r\n   * and returns an observable.\r\n   *\r\n   * @param event the object containing the file (at event.target.files[0])\r\n   * @param editForm the form group where the input field is located\r\n   * @param field the field name to set the file's 'base 64 data' on\r\n   * @param isImage boolean representing if the file represented by the event is an image\r\n   * @returns an observable that loads file to form field and completes if sussessful\r\n   *      or returns error as FileLoadError on failure\r\n   */\r\n  loadFileToForm(event: Event, editForm: FormGroup, field: string, isImage: boolean): Observable<void> {\r\n    return new Observable((observer: Observer<void>) => {\r\n      const eventTarget: HTMLInputElement | null = event.target as HTMLInputElement | null;\r\n      if (eventTarget?.files?.[0]) {\r\n        const file: File = eventTarget.files[0];\r\n        if (isImage && !file.type.startsWith('image/')) {\r\n          const error: FileLoadError = {\r\n            message: `File was expected to be an image but was found to be '${file.type}'`,\r\n            key: 'not.image',\r\n            params: { fileType: file.type },\r\n          };\r\n          observer.error(error);\r\n        } else {\r\n          const fieldContentType: string = field + 'ContentType';\r\n          this.toBase64(file, (base64Data: string) => {\r\n            editForm.patchValue({\r\n              [field]: base64Data,\r\n              [fieldContentType]: file.type,\r\n            });\r\n            observer.next();\r\n            observer.complete();\r\n          });\r\n        }\r\n      } else {\r\n        const error: FileLoadError = {\r\n          message: 'Could not extract file',\r\n          key: 'could.not.extract',\r\n          params: { event },\r\n        };\r\n        observer.error(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Method to convert the file to base64\r\n   */\r\n  private toBase64(file: File, callback: (base64Data: string) => void): void {\r\n    const fileReader: FileReader = new FileReader();\r\n    fileReader.onload = (e: ProgressEvent<FileReader>) => {\r\n      if (typeof e.target?.result === 'string') {\r\n        const base64Data: string = e.target.result.substring(e.target.result.indexOf('base64,') + 'base64,'.length);\r\n        callback(base64Data);\r\n      }\r\n    };\r\n    fileReader.readAsDataURL(file);\r\n  }\r\n\r\n  private endsWith(suffix: string, str: string): boolean {\r\n    return str.includes(suffix, str.length - suffix.length);\r\n  }\r\n\r\n  private paddingSize(value: string): number {\r\n    if (this.endsWith('==', value)) {\r\n      return 2;\r\n    }\r\n    if (this.endsWith('=', value)) {\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private size(value: string): number {\r\n    return (value.length / 4) * 3 - this.paddingSize(value);\r\n  }\r\n\r\n  private formatAsBytes(size: number): string {\r\n    return size.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ' ') + ' bytes'; // NOSONAR\r\n  }\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}