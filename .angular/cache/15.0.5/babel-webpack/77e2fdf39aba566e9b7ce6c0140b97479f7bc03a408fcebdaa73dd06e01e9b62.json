{"ast":null,"code":"import { Observable } from 'rxjs';\nimport { filter, share } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport class EventWithContent {\n  constructor(name, content) {\n    this.name = name;\n    this.content = content;\n  }\n}\n/**\r\n * An utility class to manage RX events\r\n */\nexport class EventManager {\n  constructor() {\n    this.observable = new Observable(observer => {\n      this.observer = observer;\n    }).pipe(share());\n  }\n  /**\r\n   * Method to broadcast the event to observer\r\n   */\n  broadcast(event) {\n    if (this.observer) {\n      this.observer.next(event);\n    }\n  }\n  /**\r\n   * Method to subscribe to an event with callback\r\n   * @param eventNames  Single event name or array of event names to what subscribe\r\n   * @param callback    Callback to run when the event occurs\r\n   */\n  subscribe(eventNames, callback) {\n    if (typeof eventNames === 'string') {\n      eventNames = [eventNames];\n    }\n    return this.observable.pipe(filter(event => {\n      for (const eventName of eventNames) {\n        if (typeof event === 'string' && event === eventName || typeof event !== 'string' && event.name === eventName) {\n          return true;\n        }\n      }\n      return false;\n    })).subscribe(callback);\n  }\n  /**\r\n   * Method to unsubscribe the subscription\r\n   */\n  destroy(subscriber) {\n    subscriber.unsubscribe();\n  }\n}\nEventManager.ɵfac = function EventManager_Factory(t) {\n  return new (t || EventManager)();\n};\nEventManager.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: EventManager,\n  factory: EventManager.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"AACA,SAASA,UAAU,QAAgC,MAAM;AACzD,SAASC,MAAM,EAAEC,KAAK,QAAQ,gBAAgB;;AAE9C,OAAM,MAAOC,gBAAgB;EAC3BC,YAAmBC,IAAY,EAASC,OAAU;IAA/B,SAAI,GAAJD,IAAI;IAAiB,YAAO,GAAPC,OAAO;EAAM;;AAGvD;;;AAMA,OAAM,MAAOC,YAAY;EAIvBH;IACE,IAAI,CAACI,UAAU,GAAG,IAAIR,UAAU,CAAES,QAAsD,IAAI;MAC1F,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IAC1B,CAAC,CAAC,CAACC,IAAI,CAACR,KAAK,EAAE,CAAC;EAClB;EAEA;;;EAGAS,SAAS,CAACC,KAAyC;IACjD,IAAI,IAAI,CAACH,QAAQ,EAAE;MACjB,IAAI,CAACA,QAAQ,CAACI,IAAI,CAACD,KAAK,CAAC;;EAE7B;EAEA;;;;;EAKAE,SAAS,CAACC,UAA6B,EAAEC,QAA6D;IACpG,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE;MAClCA,UAAU,GAAG,CAACA,UAAU,CAAC;;IAE3B,OAAO,IAAI,CAACP,UAAU,CACnBE,IAAI,CACHT,MAAM,CAAEW,KAAyC,IAAI;MACnD,KAAK,MAAMK,SAAS,IAAIF,UAAU,EAAE;QAClC,IAAK,OAAOH,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAKK,SAAS,IAAM,OAAOL,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACP,IAAI,KAAKY,SAAU,EAAE;UACjH,OAAO,IAAI;;;MAGf,OAAO,KAAK;IACd,CAAC,CAAC,CACH,CACAH,SAAS,CAACE,QAAQ,CAAC;EACxB;EAEA;;;EAGAE,OAAO,CAACC,UAAwB;IAC9BA,UAAU,CAACC,WAAW,EAAE;EAC1B;;AA/CWb,YAAY;mBAAZA,YAAY;AAAA;AAAZA,YAAY;SAAZA,YAAY;EAAAc,SAAZd,YAAY;EAAAe,YAFX;AAAM","names":["Observable","filter","share","EventWithContent","constructor","name","content","EventManager","observable","observer","pipe","broadcast","event","next","subscribe","eventNames","callback","eventName","destroy","subscriber","unsubscribe","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\hp\\techWebAvancee\\CRM PROJECT\\CRMFEFO\\src\\app\\service\\event-manager.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Observable, Observer, Subscription } from 'rxjs';\r\nimport { filter, share } from 'rxjs/operators';\r\n\r\nexport class EventWithContent<T> {\r\n  constructor(public name: string, public content: T) {}\r\n}\r\n\r\n/**\r\n * An utility class to manage RX events\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class EventManager {\r\n  observable: Observable<EventWithContent<unknown> | string>;\r\n  observer?: Observer<EventWithContent<unknown> | string>;\r\n\r\n  constructor() {\r\n    this.observable = new Observable((observer: Observer<EventWithContent<unknown> | string>) => {\r\n      this.observer = observer;\r\n    }).pipe(share());\r\n  }\r\n\r\n  /**\r\n   * Method to broadcast the event to observer\r\n   */\r\n  broadcast(event: EventWithContent<unknown> | string): void {\r\n    if (this.observer) {\r\n      this.observer.next(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Method to subscribe to an event with callback\r\n   * @param eventNames  Single event name or array of event names to what subscribe\r\n   * @param callback    Callback to run when the event occurs\r\n   */\r\n  subscribe(eventNames: string | string[], callback: (event: EventWithContent<unknown> | string) => void): Subscription {\r\n    if (typeof eventNames === 'string') {\r\n      eventNames = [eventNames];\r\n    }\r\n    return this.observable\r\n      .pipe(\r\n        filter((event: EventWithContent<unknown> | string) => {\r\n          for (const eventName of eventNames) {\r\n            if ((typeof event === 'string' && event === eventName) || (typeof event !== 'string' && event.name === eventName)) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        })\r\n      )\r\n      .subscribe(callback);\r\n  }\r\n\r\n  /**\r\n   * Method to unsubscribe the subscription\r\n   */\r\n  destroy(subscriber: Subscription): void {\r\n    subscriber.unsubscribe();\r\n  }\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}